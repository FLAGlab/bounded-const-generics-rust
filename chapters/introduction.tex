% !TEX root = ../main.tex
\chapter{Introduction}
\label{chapter:introduction}
The current ecosystem for systems programming has been based around having powerful and fast programming languages, mainly C and C++, those languages leave to the programmer the task of checking its code for stack overflow errors, dangling pointers, and data races; forcing them to code inefficiently to avoid such errors.

Modern programming languages try to solve this problem adding runtime mechanisms to guarantee memory safety, such as garbage collection, making them unsuitable for systems programming, where resource efficiency is vital.

The Rust programming language offers an alternative to C and C++ for systems programming, using compile time mechanisms to guarantee memory safety even for concurrent applications without sacrificing performance during execution. Even then, the current state of ergonomics in Rust can be improved and several efforts are being done by the Rust team and the community to improve the language on these regards.

This work explores the weaknesses of Rust when code needs to be generalized over constant values and proposes a solution to such problems by extending Rust's type system to allow a basic form of dependent types which will only allow constants values as indexes for types. To achieve such goal, the compiler will be modified to allow constant values as parameters for generic types:

\begin{itemize}
    \item Chapter \ref{chapter:preliminaries} offers an introduction to the Rust programming language syntax, features and compiling internals relevant to this work. This chapter does not intend to be a full introduction to the language, just an attempt to set common terminology with the reader.
    \item Chapter \ref{chapter:motivation} contains a series of code examples of the problems commonly found when working with types depending over constant values. The two problems discussed on this chapter are the implementation of traits over the type of arrays (which is a dependent type) and the optimizations done by the Rust's compiler when handling static control flow. These problems are discussed not only in terms of their ergonomics and readability, but also in terms of its compilation and execution performance.
    \item Chapter \ref{chapter:related_work} discusses related work from a theoretical and practical perspective. It includes a section about the theory of dependently typed languages which is the theoretical foundation for generic types over constant values. The following section explores the different approaches to the implementation of dependent types done by two languages: C++ templates, and the work done on Haskell's type system by Gundry \cite{gundry} and Eisenberg \cite{eisenberg}. Studies about the Rust's type system are explored afterwards, mainly the work done by Jung et al \cite{ralf}. Finally, the current state of Rust regarding dependent types is discussed in the last chapter, which includes the 2000 Rust RFC \footnote{\url{https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md}} and the typenum crate. \footnote{\url{https://crates.io/crates/typenum}}
    \item Chapter \ref{chapter:proposed_solution} proposes a solution to the problems discussed in chapter \ref{chapter:motivation}, based on the idea of adding dependent types over constant values, known in the Rust community as generics over constant values, and a possible extension adding bounds to this new kind of generic parameters.
\end{itemize}
