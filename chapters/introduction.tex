% !TEX root = ../main.tex
\chapter{Introduction}
\label{chap:introduction}
The current ecosystem for systems programming has been based around having
powerful and fast programming languages, mainly C and C++. Such languages leave
to the programmer the responsibility of checking its code for stack overflow
errors, dangling pointers, and data races; forcing them to code inefficiently
to avoid such errors.

Modern programming languages try to solve this problem by adding runtime
mechanisms to guarantee memory safety, such as garbage collection, making them
unsuitable for systems programming, where resource efficiency is vital.

The Rust programming language offers an alternative to C and C++ for systems
programming, using compile time mechanisms to guarantee memory safety even for
concurrent applications, without sacrificing performance during execution. Even
then, the current state of ergonomics in Rust can be improved and several
efforts are being done by the Rust team and the community to improve the
language on these regards.

One of the weaknesses of Rust consists of its lack of expressivenes when
constant expressions need to be abstracted from code. This limits the
capabilities of the language regarding the implementation of traits and
functions for arrays of all sizes and it also limits the optimization
capabilities of the compiler regarding constant propagation.

This work proposes a solution to such problems by interfacing the Rust compiler
with a simbolic execution engine to allow a basic form of dependent types which
will only allow constants values as indexes for types. This work also discusses
new possible features of the compiler regarding type checking, trait
specialization and generic types:

\begin{itemize}
    \item \Fref{chap:preliminaries} offers an introduction to the Rust
        programming language syntax, features and compiling internals relevant
        to this work. This chapter does not intend to be a full introduction to
        the language, just an attempt to set common terminology with the
        reader.
    \item \Fref{chap:motivation} contains a series of code examples of the
        problems commonly found when working with types depending over constant
        values. The two problems discussed on this chapter are the
        implementation of traits over the type of arrays and the optimizations
        done by the Rust's compiler when handling static control flow. These
        problems are discussed in terms of their ergonomics, readability,
        compilation and execution performance.
    \item \Fref{chap:related_work} discusses related work from a theoretical
        and practical perspective. It includes a section about the
        different approaches to abstracting constants done by
        two languages: the C++ template system, and the work done on Haskell's type
        system by Gundry \cite{gundry} and Eisenberg \cite{eisenberg}. Studies
        about the Rust's type system are explored afterwards, mainly the work
        done by Jung et al \cite{ralf}. Finally, the current state of Rust
        regarding dependent types is discussed in the last section, which
        includes the current partial solution using macros, RFC-2000
        \footnote{\url{https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md}}
        and the typenum crate.
        \footnote{\url{https://crates.io/crates/typenum}}
    \item \Fref{chap:solution} proposes a solution to the problems discussed in
        \fref{chap:motivation}, based on the idea of adding dependent types
        over constant values, known in the Rust community as generics over
        constant values, and a possible extension adding bounds to this new
        kind of generic parameters.

    \item \Fref{chap:validation} presents the validation of our work. This is done
        comparing the implementation differences between an small vector
        library with and without our proposals.

    \item \Fref{chap:conclusion} presents the conclusion and discusses avenues of future
        work.
\end{itemize}
