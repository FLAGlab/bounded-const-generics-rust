% !TEX root = ../main.tex
\chapter{Preliminaries}
\label{chapter:preliminaries}

Rust \footnote{https://www.rust-lang.org/} is a systems programming language focused on speed, memory safety and concurrency. It intends to offer both performance similar to C++ and memory safety similar to Haskell. Rust is a compiled language combining imperative and functional programming features. The focus on performance makes Rust an ideal candidate for writing operative systems, databases, compilers, and other high-performance software without worrying about manual memory allocation. However, Rust's safety and high-level abstractions has encouraged its usage in backend and even frontend development. 

Rust started as a personal project of Graydon Hoare during 2006, who wanted to write a memory-safe, suited for concurrency and compiled language. After three years, Mozilla endorsed the project and Rust was announced to the public during 2010. Since then Rust's development has been completely open to the community. In 2013, Hoare stepped down as the technical leader of the project and a core team for the project was formally established. \cite{steve_acm} Version 1.0 was released in May, 2015, following a six weeks release cycle enforcing semantic versioning, the current version of the Rust compiler \footnote{This is version 1.31} is completely backwards compatible with 1.0.

Currently, several companies have written in Rust part of their core applications (including Mozilla, which is working on its next generation web engine: \href{https://servo.org/}{Servo}) as can be seen in \href{https://www.rust-lang.org/en-US/friends.html}{Rust Friends website}.

In the remaining part of this section contains a quick tour of the Rust programming language main features. Readers more experienced with Rust can easily skip it.

\section{Mutability}
Variable declarations are done using the \texttt{let} keyword. However, all variables are immutable by default as shown in \ref{lst:immutable}.

\begin{listing}[h]
	\begin{minted}{rust}
    fn main() {
        let x = 5;
        x += 1; // stderr: cannot assign twice to immutable variable `x`
        println!("{}", x);
    }
	\end{minted}
  \caption{Trying to modify an immutable value will result in a compilation error}
  \label{lst:immutable}
\end{listing}

Mutability is allowed using the \texttt{mut} keyword as shown in \ref{lst:mutable}. The explicitness of mutability not only allows the compiler to do optimizations, it is also useful to the programmer, if a variable is not declared explicitly as mutable, its value will not change during its whole lifetime.

\begin{listing}[h]
	\begin{minted}{rust}
    fn main() {
        let mut x = 5;
        x += 1;
        println!("{}", x); // stdout: 6 
    }
	\end{minted}
  \caption{Mutability is allowed but it must be explicit}
  \label{lst:mutable}
\end{listing}

\section{Memory management}
In Rust, memory safety checks are done during compilation, avoiding the need for a garbage collector or manual memory management. The Rust compiler can reason about memory usage via three concepts: Ownership, borrowing and lifetimes.

\subsection{Ownership}
The semantics of value assignation in Rust differs from the traditional one. When assigning a value to a variable the state of the program change as usual, but the variable becomes the new \textit{owner} of such value. This means that the value will be dropped when its owner goes out of scope. Each value can only have a single owner at the same time. Meaning that for each value stored in memory there is exactly a single variable owning it. 

When a value is reassigned to another variable, ownership is transfered i.e, the former owner loses the ownership and it cannot be used again unless a new value is assigned to it. As a consequence, when a variable is used as a function argument, the variable loses ownership of its value, and the variable representing the argument of the function becomes the new owner. This behavior can be seen on \ref{lst:ownership}.

\begin{listing}[h]
	\begin{minted}{rust}
    fn exclamate(z: String) {
        println!("{}!", z);
    }

    fn main() {
        let x = String::from("Hello, world");
        let mut y = x; // y` is the new owner, `x` is invalid.
        exclamate(y); // `z`is the new owner, `y` is invalid.
        println!("{}", x); // stderr: use of moved value: `x`
        println!("{}", y); // stderr: use of moved value: `y`
    }
	\end{minted}
  \caption{Ownership transfer}
  \label{lst:ownership}
\end{listing}

This ownership restriction has two advantages: First, is impossible to have a value stored in memory without a variable in the current scope assigned to it, avoiding some memory leaks. Second, is impossible to modify a single value from several different threads, avoiding data races. Nevertheless, ownership forces the programmer to write code akin to continuation-passing style, which is error-prone and difficult to read. The \textit{borrowing} concept (described in the next subsection) solves this issue.

\subsection{Borrowing}
Rust is a language with pointers or references. When a reference to a value is created, such value is being borrowed (but ownership is not transferred). There are two kind of references in Rust: immutable references denoted by \texttt{&T} and mutable references \texttt{&mut T}. Immutable references allow "read-only" access, independently of the referenced variable mutability. Mutable references allow "read and write" access, but they only reference mutable variables. Examples of both kinds of references can be found in \ref{lst:immutable_ref} and \ref{lst:mutable_ref}.

\begin{listing}[h]
	\begin{minted}{rust}
    fn exclamate(z: &String) {
        println!("{}!", z);
    }

    fn main() {
        let x = String::from("Hello, world");
        exclamate(&x); // `z` is borrowing the value owned by `x`.
                       // stdout: Hello, world! 
        println!("{}", x); // stdout: Hello, world
    }
	\end{minted}
  \caption{References avoid the need for ownership transfer}
  \label{lst:immutable_ref}
\end{listing}

There are three rules about borrowing enforced by the compiler:
\begin{itemize}
    \item Several immutable references to a value can exist at a given time.
    \item There must be at most one mutable reference to a value at a given time.
    \item The first two scenarios are exclusive, only one of them can happen at the same time.
\end{itemize}

\begin{listing}[h]
	\begin{minted}{rust}
    fn exclamate_in_place(z: &mut String) {
        z += &"!";    
    }

    fn main() {
        let mut x = String::from("Hello, world");
        exclamate(&mut x); // `z`is borrowing the value owned by `x`.
        println!("{}", x); // stdout: Hello, world!
    }
	\end{minted}
  \caption{Mutable references allow mutation of the borrowed value}
  \label{lst:mutable_ref}
\end{listing}

In other words, is possible to do just one of the following at the same time: Have several readers or, have a single writer. This prevents the mutation of shared state and, as a consequence, prevents data races in concurrent applications. There are certain scenarios where the borrowing rules are not flexible enough to allow certain kind of behaviors, such as locks for example, in those cases is possible to use types with internal mutability, the \texttt{Mutex} type is an example of this.

\subsection{Lifetimes}
Adding references to a language makes possible to have dangling references. When a value is dropped, all its references become dangling references and they no longer point to a valid memory location. To solve this memory issue, Rust introduces the concept of lifetimes, each value has a lifetime which starts when the value is allocated and ends when the value is dropped. As a consequence, a value lifetime ends when its owner goes out of scope. Rust compiler has a "borrow checker", which compares scopes to check that no reference outlives the value being referenced. If this is not the case, a compilation error will occur.

In principle, every reference needs a lifetime annotation. However, this is avoided by a process known as lifetime elision, where lifetimes are inferred automatically by the compiler. Even then, in certain cases the programmer might need to add such annotations. However, this will be discussed in the generics section.

\section{Algebraic data types}
\section{Control flow}
\section{Generics}

\section{Traits}
Traits are Rust's mechanism to allow ad-hoc polymorphism, they allow to extend the behavior of a type requiring that the type implements a set of methods defined by the trait. The main difference between using traits instead of generic functions consist in the possibility to use concrete properties of an specific type when implementing the trait.

\begin{listing}[h]
	\begin{minted}{rust}
    trait Volatile {
        fn explode(&self);
    }

    impl Volatile for i32 {
        fn explode(&self) {
            for _ in 0..*self {
                println!("Boom!");
            }
        }
    }
    \end{minted}
  \caption{Implementation of an user defined trait for a foreign type}
  \label{lst:trait_foreign_impl}
\end{listing}

User defined traits can be implemented for any type, in contrast to Java interfaces where the implementations are restricted to the types declared in the same package as the interface, as in \ref{lst:trait_foreign_impl}. On the other hand, the user can implement a foreign trait for its own types, as in \ref{lst:foreign_trait_impl}. However, the user can not implement foreign traits for foreign types as shown in \ref{lst:foreign_trait_foreign_impl}.

\begin{listing}[h]
	\begin{minted}{rust}
    use std::ops::Add;

    struct Rational {
        a: i32,
        b: i32,
    }

    impl Add for Rational {
        type Output = Rational;
        
        fn add(self, other: Rational) -> Rational {
            Rational {
                a: self.a * other.b + other.a * self.b,
                b: self.b * other.b
            }
        }
    }
    \end{minted}
  \caption{Implementation of a foreign trait for an user defined type}
  \label{lst:foreign_trait_impl}
\end{listing}

Traits can have associated types, such types can be used in the signature of the trait associated functions to allow more expressiveness, as an example, in \ref{lst:trait_foreign_impl}, \texttt{Output} is an associated type of \texttt{Add} and it can be used as the return type of the \texttt{add} method, allowing the addition of two variables of the same type, return a different type. It is also possible to parametrize traits using types and lifetimes, i.e., generic traits.

\begin{listing}[h]
	\begin{minted}{rust}
    use std::ops::Add;

    impl Add for bool { // stderr: only traits defined in the
                        // current crate can be implemented 
                        // for arbitrary types.
        type Output = bool;
        
        fn add(self, other: bool) -> bool {
            self || other
        }
    }
    \end{minted}
  \caption{Trying to implement a foreign trait for a foreign type will result in a compilation error}
  \label{lst:foreign_trait_foreign_impl}
\end{listing}

Traits are used for operator overloading, e.g., the types that can be operated with \texttt{+} must implement the \texttt{Add} trait of the standard library, \ref{lst:foreign_trait_impl} is an example of this. 

Thread safety is also handled using traits. Types which are thread-safe to send must implement the \texttt{Send} trait and types which are thread-safe to share (using references) must implement the \texttt{Sync} trait. Both traits are empty , i.e., they do not request any function to be implemented, but are unsafe traits because the compiler can not guarantee the safety of sending or sharing values of a certain type.

\section{Error handling}
\section{Macros}
\section{Intermediate representations}
Rust code is not compiled directly into machine code, instead is compiled into a series of intermediate representations. On early versions, Rust code suffered a desugaring process (this representation is known as the high-level intermediate representation or HIR) before being compiled into the LLVM intermediate representation and finally it was compiled to machine code. \footnote{https://rust-lang-nursery.github.io/rustc-guide/codegen.html}

\begin{figure}[h]
  \centering
  \includegraphics[height=1.5cm]{images/original_pipeline.pdf}
  \caption{Rust's compilation pipeline before 2016.}
\end{figure}

During 2016, Rust added the mid-level intermediate representation or MIR to its compilation pipeline. This new representation improved the borrow checking and optimization processes, allowing for both faster and more readable code. \footnote{https://blog.rust-lang.org/2016/04/19/MIR.html} 

On this same year, miri, an intepreter for the MIR was written. This interpreter can execute code written in the MIR directly instead of compiling it to machine code. \footnote{https://solson.me/miri-report.pdf} However, Rust is still a compiled language, miri is not used currently by the Rust project as a "virtual machine". Instead, miri is used to evaluate constant expressions during compilation.

\begin{figure}[h]
  \centering
  \includegraphics[height=1.5cm]{images/current_pipeline.pdf}
  \caption{Rust's compilation pipeline after 2016.}
\end{figure}
