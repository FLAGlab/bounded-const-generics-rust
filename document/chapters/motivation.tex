% !TEX root = ../main.tex
\chapter{Motivation}
\label{chapter:motivation}
\section{Trait implementations for arrays}
In Rust, all the types have a fixed size that must be known during compilation \footnote{Trait objects and slices are exeception to this, but the programmer can only use those types via references (which have a fixed size).}. As a consequence, two arrays with different sizes have different types, even if both store values of the same type. Thus, trait implementations for array types must be done manually for each possible size. Because of this, the standard library only implements traits for array types up to a size of 32, even though arrays are a primitive type of the language. An example of this limitation can be found on \ref{lst:trait_array}.

In certain cases vectors are used instead of arrays. However, vectors require heap allocation, making them unsuitable for applications running on embedded devices (which may not allow heap allocation) and also slower to access compared to arrays.

\begin{listing}
	\begin{minted}{rust} 
    const N: usize = 3;

    trait Volatile {
        fn explode(&self);
    }

    impl<T> Volatile for [T; N] {
        fn explode(&self) {
            for _ in self {
                println!("Boom!")
            }
        }
    }

    fn main() {
        [0i32, 1, 2].explode(); 
        [0i32, 1].explode(); // stderr: no method named `explode` 
                             // found for type `[i32; 2]` in the
                             // current scope
    }
	\end{minted}
    \caption{Even though \texttt{Volatile} is implemented for \texttt{[T; 3]}, it is not for \texttt{[T;2]}}.
  \label{lst:trait_array}
\end{listing}

Allowing the language to have constants as generic parameters of types (in the same way as types and lifetimes) would allow the programmer to provide a single implementation of a trait for all possible array sizes without additional effort, as shown in \ref{lst:const_trait_array}. The implementation of this feature has been approved by the Rust team and it is a work in progress.

\begin{listing}
	\begin{minted}{rust} 
    trait Volatile {
        fn explode(&self);
    }

    impl<const N usize, T> Volatile for [T; N] {
        fn explode(&self) {
            for _ in self {
                println!("Boom!")
            }
        }
    }

    fn main() {
        [0i32, 1, 2].explode(); 
        [0i32, 1].explode();
    }
	\end{minted}
    \caption{Having constant values as generic parameters would allow the programmer to provide a single generic implementation for all possible array sizes.}
  \label{lst:const_trait_array}
\end{listing}

\section{Static control flow and optimizations}
Even if constant values are allowed as parameters for generic types. If the constant generics implementation included bounds over constant parameters it would be possible to manage control flow involving constants during compilation instead. Not only making the code more compact, but also removing the need for  error handling in certain cases.

An small illustration of this problem can be seen on \ref{lst:const_no_bounds}, where the array size \texttt{N} is a constant value known during compilation. Rust in its current state can do constant evaluation, the expression \texttt{N > 0} can be evaluated and the compiler will remove the dead arm of the \texttt{if} statement. In other words, during specialization, Rust will be able to produce a function returning \texttt{None} for empty arrays, and another function returning \texttt{Some(array[0])} for non-empty arrays.

Given that specialization happens on demand, i.e., only when a polymorphic type is instantiated using an specific set of parameters. The compiler will not optimize \texttt{head} as written above if the function is not called.

If \text{head} was rewritten using bounds for constant parameters as in \ref{lst:const_bounds}, the compiler will verify that \texttt{N > 0} only when \texttt{N} is given (in the same way as \ref{lst:const_no_bounds}). However, there is no need for additional optimizations. Also, the return type was simplified to \texttt{T} instead of \texttt{Option<T>}, removing the need for additional control flow when using \texttt{head} elsewhere.

In other words, adding the capability to bound constant parameters, allows the programmer to write more compact code, removing the need for compiler optimizations in certain cases.

\begin{listing}
    \begin{minted}{rust}
    fn head<const N usize, T>(array: [T; N]) -> Option<T> {
        if N > 0 {
            Some(array[0])
        } else {
            None
        }
    }
    \end{minted}
    \caption{A function with a constant parameter in its type with regular control flow.}
    \label{lst:const_no_bounds}
\end{listing}

\begin{listing}
    \begin{minted}{rust}
    fn head<const N usize, T>(array: [T; N]) -> T with {N > 0} {
        array[0]
    }
    \end{minted}
    \caption{A function with a constant parameter in its type, with control flow done during compilation using bounds.}
    \label{lst:const_bounds}
\end{listing}
